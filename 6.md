## 상속
- 부모클래스가 자식 클래스에게 물려주는 행위이며, 자식은 상속을 통해서 부모클래스에 명시된 필드나 메소드를 이용가능하다.
- 상속은 부모클래스를 이용해 새로운 클래스를 만들기 때문에 코드의 중복을 줄여줄수 있다. 
```java
public class A{
	int field;
	void method(){}
}

//A 클래스를 상속받은 B 클래스
public class B extends A{
	String field2;
	void method2(){} 
}

B b = new B();
b.field= 10;
b.method();

b.field2="홍길동";
b.method2();
```

## 클래스 상속 특징
- 상속은 부모가 자식을 선택해서 물려주지만, 프로그램에서는 자식이 부모를 선택한다
- 자바는 다중상속을 허용하지 않는다.

##  생성자 호출
- 자식 클래스의 생성자 호출시 **부모객체가 먼저 생성되고 자식객체**가 그 다음에 생성된다. 
	```java
	A 클래스 생성 후 B 클래스가 생성된다. 
	B b = new B();
	```
- 자식 클래스 생성자 호출시 컴파일러는 다음과 같이 동작한다.
	>  부모 생성자는 자식생성자의 맨 첫줄에서 부모의 기본생성자를 super() 메서드로 호출한다 
	```java
	public B(){
		super(); // 부모의 기본 생성자를 호출한다.
	}
	```
	```mermaid
	graph LR
	A[B class] --> B(B class super method) --> C[A class] 
	```
- 부모클래스에 생성자가 선언되지 않았더라도, 기본 생성자가 만들어지므로 문제없이 실행된다.

- 직접 자식생성자를 선언하고 명시적으로 부모 생성자를 호출하고 싶다면 아래와 같은 코드를 작성해주면, 매개값 타입과 일치하는 부모생성자를 호출한다. 
	 > 만약 일치하는 부모생성자가 없을 경우 컴파일 오류가 발생한다.
	```java
	자식클래스(매개변수, ..){
		super( 매개값,...);
	}

	B(String a, String b){
		super(a, b);
	}

	A(String a, String b){
		....
	}
	```
- 예시 
```java
public class People{
	public String name;
	public String ssn;

	public People(String name, String ssn){
		this.name = name;
		this.ssn=ssn;
	}
	
	public void f1(){
		System.out.println("f1 method() 호출");
	}
}

public class Student extends People{
	public int studentNo;
	public Student(String name, String ssn, int studentNo){
		super(name,ssn);
		this.studentNo = studentNo;
	}
	
	public void getSuperF1(){
		super.f1(); // 부모생성자의 method도 이와같이 호출한다.
	}
}
```

## 메소드 오버라이딩
- override 는 사전적 의미로** 강한 명령 ** 을 의미한다. 자바에서의 오버라이드는 상속받은 클래스의 메소드 명만 위임을 받고 **기존 메서드를 무시**하며 **재정의** 함을 뜻한다.
	> overloading 은 사전적의 의미로 과적을 뜻하며, **동일 메소드에 매개변수에 따라 기능이 추가**되는 것을 의미한다.
	```java
	class P{
		void m();
		void m1();
	}

	class C extends P{
		void m1(); //재정의
		void m2();
	}

	C c = new C();
	c.m(); P 클래스 메서드 실행
	c.m1() : P 클래스의 메소드의 명만 위임을 받고 C의 m1 메소드가 실행 즉 override
	c.m2() : C 클래스 메소드 실행
	```
- 예제 : 원넓이를 구하는 클래스
	```java
	class Calculator{
		double areaCircle(double r){
			return 3.14 * r * r;
		}
	}

	class Computer extends Calculator{
		@Override
		double areaCircle(double r){
			return Math.PI * r * r;
		}
	}

	//main
	Calculator c = new Calculator();
	caculator.areaCircle(r);

	Computer com = new Computer();
	computer.areaCircle(r); // 오버라이드된 메소드 호출 
	```
- @Override 는 생략하여도 되나, 기술할 것을 권고하고 있다. 이를 명시하게 되면 areaCircle() 이 정확히 오버라이딩된 것인지 컴파일러가 체크하기 때문에 개발자의 실수를 줄여준다. 


## final 클래스 및 메소드
- final 키워드는 클래스, 필드, 메소드 선언시 사용할수 있으며, 해당 선언이 **말 그대로 final 최종 상태**이고, 수정할 수 없음을 나타낸다.
	
-  final 클래스 아래와 같이 명시하며, **상속할 수 없다. 대표적으로 String은 final 클래스 중 하나인데, String 클래스는 어떠한 클래스도 상속받지** 못한다. 
	```java
	public final class 클래스{...}
	```
- 또한 수정이나 상속받을 수 없기 때문에 메소드나 생성자 override도 할 수 없다.

## Dynamic Method Dispatch
- 오버로딩의 경우 컴파일시에 어떤 메소드를 사용할지 결정되지만, 오버라이딩은 런타임시 결정된다.
- 오버라이딩의 런타임 호출에 대한 메커니즘을 Dynamic Method Dispatch 라고 부른다.
	```java
	class A{
		void m1(){
			System.out.println("A.m1");
		}
	}
	
	class B extends A{
		@Override
		void m1(){
			System.out.println("B.m1");
		}
	}
	
	class C extends A{
		@Override
		void m1(){
			System.out.println("A.m1");
		}
	}

	```
	- 부모클래스 참조변수는 자식클래스 객체를 지칭할 수 있으며, 이를 업캐스팅이라 한다.
		```java
		A SuperASubB = new B();
		
		//부모클래스 참조변수 : A
		//자식클래스 객체 : B
		```

	-  오버라이딩된 메소드는 상위 클래스 참조를 통해 호출될때, 참조되는 객체 유형에 따라 런타임시 메서드 버전이 결정된다 
		```java
		A SuperASubB = new B();
		
		//참조변수 A
		//참조되는 객체 유형 : B
		```
	- 런타임에서 재정의된 메서드 버전을 결정하는 것은 참조되는 개체 유형에 따라 결정된다.
		```java
		A SuperASubC = new C();
		SuperASubC.m1(); // B.m1;
		
		//참조변수 A
		//참조되는 객체 유형 : C
		//사용되는 메소드 : C.m1
		```

## 추상클래스
- 객체를 직접 생성할 수 있는 클래스를 실체클래스라 한다면, 이 클래스들의 공통적인 특성을 추출하여 선언한 클래스를 추상클래스라 한다. 
	```java
	/*
	추상클래스의 선언
	*/
	abstract class Animal{
		....
	}
	
	class Cat extends Animal{
		...
	}
	
	class Dog extends Animal{
		...
	}

	```
- 추상클래스는 실체클래스와 상속관계이며, 객체를 직접 생성할 수 없다.
	```java
	Animal a = new Animal(); // XXXXX 객체 생성 불가
	```


- 추상클래스의 용도
	- 실체클래스들의 공통된 필드와 메소드 이름을 통일하면서 작성시간을 줄인다. 
- 추상클래스의 선언
	```java
	public abstract class 클래스명{
		//필드
		//생성자
		//메소드
	}
	```
- 추상클래스와 실체클래스 응용
	```java
	public abstract class Phone{
		public String owner;
		
		public Phone(String owner){
			this.owner = owner;
		}
		
		public void turnOn(){
			System.out.println("on");
		}
		
		public void turnOff(){
			System.out.println("off");
		}
	}
	
	public class SmartPhone extends Phone{
		public SmartPhone(String owner){
			super(owner);
		}
		
		public void internetSearch(){
			System.out.println(*
		}
	}

	//main
	Phone p = new Phone(); // 불가 추상클래스
	
	SmartPhone s = new SmartPhone();
	s.turnOne();
	s.internetSearch();
	s.turnOff();
	```
	
## 추상메소드 오버라이딩
- 모든 실체들이 가지고 있는 메소드의 실행 내용이 동일하다면 추상 클래스에 작성하는게 좋다.
- 하지만 실행 메소드가 상속 받은 실체 클래스마다 달라야한다면  실체클래스에서 직접 작성해야한다. 
- 이런 경우 추상클래스는 추상메소드를 선언할수 있으며, 추상메소드는 메소드 선언부만 있고 실행내용인 {} 가 없는 메소드를 뜻한다.
	```java
	public abstract 리턴타입 메소드명 (매개변수);
	```
- 추상클래스를 설계할때 하위 클래스가 반드시 실행 내용을 채우도록 강요하고 싶은 메소드가 있을 경우, 해당 메소드를 추상메소드로 선언하면 된다. 
	```java
	public abstract class Animal{
		public abstract vodi sound();
	}
	
	public abstract class Animal{
		public String kind;
		
		public void breathe(){
			System.out.println("breathe");
		}
		
		public abstract void sound();
	}

	public class Dog extends Animal{
		public Dog(){
			this.kind = "포유류";
		}
		
		@Override // 무조건 오버라이딩을 해줘야함. 하지 않으면 컴파일 에러가 발생한다.
		public void sound(){
			System.out.println("멍");
		}
	}
	```
