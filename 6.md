## 상속
- 부모클래스가 자식 클래스에게 물려주는 행위이며, 자식은 상속을 통해서 부모클래스에 명시된 필드나 메소드를 이용가능하다.
- 상속은 부모클래스를 이용해 새로운 클래스를 만들기 때문에 코드의 중복을 줄여줄수 있다. 
```java
public class A{
	int field;
	void method(){}
}

//A 클래스를 상속받은 B 클래스
public class B extends A{
	String field2;
	void method2(){} 
}

B b = new B();
b.field= 10;
b.method();

b.field2="홍길동";
b.method2();
```

## 클래스 상속 특징
- 상속은 부모가 자식을 선택해서 물려주지만, 프로그램에서는 자식이 부모를 선택한다
- 자바는 다중상속을 허용하지 않는다.

##  생성자 호출
- 자식 클래스의 생성자 호출시 **부모객체가 먼저 생성되고 자식객체**가 그 다음에 생성된다. 
	```java
	A 클래스 생성 후 B 클래스가 생성된다. 
	B b = new B();
	```
- 자식 클래스 생성자 호출시 컴파일러는 다음과 같이 동작한다.
	>  부모 생성자는 자식생성자의 맨 첫줄에서 부모의 기본생성자를 super() 메서드로 호출한다 
	```java
	public B(){
		super(); // 부모의 기본 생성자를 호출한다.
	}
	```
	```mermaid
	graph LR
	A[B class] --> B(B class super method) --> C[A class] 
	```
- 부모클래스에 생성자가 선언되지 않았더라도, 기본 생성자가 만들어지므로 문제없이 실행된다.

- 직접 자식생성자를 선언하고 명시적으로 부모 생성자를 호출하고 싶다면 아래와 같은 코드를 작성해주면, 매개값 타입과 일치하는 부모생성자를 호출한다. 
	 > 만약 일치하는 부모생성자가 없을 경우 컴파일 오류가 발생한다.
	```java
	자식클래스(매개변수, ..){
		super( 매개값,...);
	}

	B(String a, String b){
		super(a, b);
	}

	A(String a, String b){
		....
	}
	```
- 예시 
```java
public class People{
	public String name;
	public String ssn;

	public People(String name, String ssn){
		this.name = name;
		this.ssn=ssn;
	}
	
	public void f1(){
		System.out.println("f1 method() 호출");
	}
}

public class Student extends People{
	public int studentNo;
	public Student(String name, String ssn, int studentNo){
		super(name,ssn);
		this.studentNo = studentNo;
	}
	
	public void getSuperF1(){
		super.f1(); // 부모생성자의 method도 이와같이 호출한다.
	}
}
```

## 메소드 오버라이딩
- override 는 사전적 의미로** 강한 명령 ** 을 의미한다. 자바에서의 오버라이드는 상속받은 클래스의 메소드 명만 위임을 받고 **기존 메서드를 무시**하며 **재정의** 함을 뜻한다.
	> overloading 은 사전적의 의미로 과적을 뜻하며, **동일 메소드에 매개변수에 따라 기능이 추가**되는 것을 의미한다.
	```java
	class P{
		void m();
		void m1();
	}

	class C extends P{
		void m1(); //재정의
		void m2();
	}

	C c = new C();
	c.m(); P 클래스 메서드 실행
	c.m1() : P 클래스의 메소드의 명만 위임을 받고 C의 m1 메소드가 실행 즉 override
	c.m2() : C 클래스 메소드 실행
	```
- 예제 : 원넓이를 구하는 클래스
	```java
	class Calculator{
		double areaCircle(double r){
			return 3.14 * r * r;
		}
	}

	class Computer extends Calculator{
		@Override
		double areaCircle(double r){
			return Math.PI * r * r;
		}
	}

	//main
	Calculator c = new Calculator();
	caculator.areaCircle(r);

	Computer com = new Computer();
	computer.areaCircle(r); // 오버라이드된 메소드 호출 
	```
- @Override 는 생략하여도 되나, 기술할 것을 권고하고 있다. 이를 명시하게 되면 areaCircle() 이 정확히 오버라이딩된 것인지 컴파일러가 체크하기 때문에 개발자의 실수를 줄여준다. 


## final 클래스 및 메소드
- final 키워드는 클래스, 필드, 메소드 선언시 사용할수 있으며, 해당 선언이 **말 그대로 final 최종 상태**이고, 수정할 수 없음을 나타낸다.
	
-  final 클래스 아래와 같이 명시하며, **상속할 수 없다. 대표적으로 String은 final 클래스 중 하나인데, String 클래스는 어떠한 클래스도 상속받지** 못한다. 
	```java
	public final class 클래스{...}
	```
- 또한 수정이나 상속받을 수 없기 때문에 메소드나 생성자 override도 할 수 없다.
